package com.sist.exception;

import java.util.ArrayList;
import java.util.List;

/*
 *    3. final 클래스 => 종단 클래스 (java.lang)
 *    ----------- 확장을 할 수 없다 (있는그대로 사용) => 상속을 내리질 못한다 
 *                상위 클래스가 될수 없다.
 *    java.lang, util, io net, text
 *    ----------------------------- 기본 라이브러리
 *    java.sql , javax ... http.servlet, xml....
 *    
 *    4. 오버라이딩(상속의 기본) => 변경해서 사용(다형성)
 *       객체지향의 3대 요소
 *       1. 데이터 보호 목적
 *          캡슐화 : 변수를 은닉화 -> 메소드를 통해서 접근이 가능하게 만든다.
 *                  ---------private        ---------- public
 *                   => 변수는 2가지 기능만 수행
 *                      메모리 저장 / 메모리 데이터 읽기
 *                      --------   --------------
 *                      setter     getter
 *                   => 모든 멤버변수 : private
 *                   => 모든 메소드(생성자) : public => 다른 클래스와 연결이 가능
 *              접근지정어
 *              -------
 *              1) private : 자신의 클래스에서만 사용이 가능
 *                           다른 클래스에서는 접근이 불가능
 *              2) default : 같은 패키지에서만 접근이 가능 
 *              3) public : 공개(패키지 상관없이 모든 클래스에 접근이 가능)
 *       2. 재사용 목적 : 상속, 포함  ==> 클래스의 크기 결정 => 형변환
 *          class A 
 *          class B extends A => A가 가지고 잇는 모든 내용을 가지고온다.
 *                  ------- A의 내용을 변경해서 사용, 추가가 가능하다.
 *                          라이브러리 -> 프로그램에 맞지 않는 경우(수정) 
 *          ================== A(상속을 내린 클래스) > B(상속을 받은 클래스)
 *            => A a = new A();
 *            => B b = new B();
 *            => A c = new B(); 묵시적 형변환 (자동)
 *                 --------> 추상클래스/인터페이스 (메모리할당이 안된다)
 *                           ---------------- 
 *                           메모리 할당시에 상속을 받은 클래스를 이용해서 메모리 할당을 한다
 *                           미완성 클래스(메소드가 구현이 안된 상태)
 *                           => 설계 , 같은 기능 (처리를 프로그램에 맞게 할때)
 *                                    버튼클릭 , 마우스클릭...
 *                                    게시판 : 글쓰기, 
 *            => Bd = (B)c; 명시적 형변환 (강제)
 *            
 *            클래스를 저장해서 관리(클래스) => Collection
 *            
 *          class A{
 *              B b = new B(); // 특별한 경우가 아니면 재정의 하지 않는다.
 *          }     
 *          class B
 *       3. 수정, 추가 목적 (유지보수)
 *          수정 오버라이딩, 추가(오버로딩)
 *          
 *          -----------------------------------------------------
 *                       오버로딩                 오버라이딩
 *          -----------------------------------------------------
 *          관계           한개의 클래스            상속관계
 *                        상속관계  
 *          -----------------------------------------------------
 *          메소드명        동일                   동일 
 *          -----------------------------------------------------
 *          매개변수        갯수나                 동일
 *                       데이터형이 다르다
 *          -----------------------------------------------------
 *          리턴형         관계없음                동일
 *          -----------------------------------------------------
 *          접근지정       관계없음                 확장가능
 *          -----------------------------------------------------
 *          사용처         생성자                  인터페이스/추상클래스
 *          -----------------------------------------------------
 *          *** 상속
 *          1) 호출 => 상위클래스의 생성자가 먼저 호출 (기본생성자)
 *             class A{
 *                 => public A(){} -> 매개변수 생성자를 만들려면 기본생성자를 선언해야함 문제 1번
 *                 public A(int a){}
 *             }
 *             class B extends A{
 *                  public B(int a, int b){}
 *             }
 *             B b = new B();
 *               -> new A() => new B();
 *          2) 예외조건 static, 생성자, 초기화 블럭, private
 *          
 *          class A
 *          class B extends A
 *          class D extends B
 *          class B extends A
 *          class E extends B
 *          class B extends A
 *          -----------------------
 *          A a = new A();
 *          A a = new B()l
 *          B b = new B();
 *          B b = new D();
 *          B b = new E();
 *          ------------------------
 *          
 *          ------------------------
 *          B b = n
 *          
 *          
 *          
 *        ----------------------------------------------------------
 *        클래스의 종류
 *        = 추상클래스
 *        = 인터페이스 => 추상클래스의 단점을 보완 (클래스와 동일하게 취급)
 *          ** 클래스(단일) / 인터페이스(다중)
 *        --- 설계도(구현이안된상태) => 미완성 클래스 (자신이 메모리 할당을 할 수 없다.)
 *        --- 여러개의 관련된 클래스를 모아서 한개의 객체명으로 제어
 *        ----------------------------------------------------------
 *                           추상클래스              인터페이스
 *        ----------------------------------------------------------
 *        상속관계              단일상속               다중상속
 *        ----------------------------------------------------------
 *        상속키워드            extends             implements
 *        ----------------------------------------------------------
 *        멤버변수             인스턴스             상수형변수만 사용               
 *                           정적변수 
 *        ----------------------------------------------------------
 *        메소드              구현된 메소드         구현이 안된 메소드
 *                          구현이 안된 메소드
 *        ----------------------------------------------------------
 *        기법               오버라이딩               오버라이딩
 *        ----------------------------------------------------------
 *        형식  
 *        
 *           추상클래스
 *           [접근지정어] abstract class ClassName{
 *                 -------------------------------
 *                 
 *                 -------------------------------
 *                 변수
 *                   인스턴스 변수
 *                   static 변수
 *                 -------------------------------
 *                 메소드
 *                   구현된 메소드
 *                   [접근지정어] 리턴형 메소드명(매개변수..){
 *                   
 *                   }
 *                   구현이 안된 메소드(선언)
 *                   [접근지정어] abstract 리턴형 메소드명(매개변수..);
 *                             --------
 *                 -------------------------------
 *                  생성자, 오버로딩이 가능
 *                 -------------------------------
 *           }
 *           인터페이스
 *           [접근지정어] interface interface명{
 *                -------------------------------
 *                변수선언 (상수형변수)
 *                   int a = 10;  => 값을 명시적으로 지정
 *                   => (public static final) int a = 10; // 자동 추가
 *                -------------------------------
 *                 구현이 안된 메소드 목록
 *                 void display();
 *                  => public abstract void display();
 *                     --------------- 자동추가
 *                   
 *                -------------------------------
 *                 구현한 메소드 목록
 *                 default void aaa(){} //  일반메소드
 *                   => public default void aaa(){}
 *                 static void bbb(){}  //  정적 메소드
 *                   => public static void bbb(){}
 *                -------------------------------
 *           }
 *           ===> 인터페이스는 변수나 메소드가 public (연결 목적 => 언제든 연결이 가능)
 *        ----------------------------------------------------------
 *        
 *        상속
 *        interface => interface => extends
 *        interface => class => implements
 *        
 *        다중 상속 
 *        class A implements 인터페이스, 인터페이스....
 *          
 *       
 *    
 *    
 */
class AAA{
	int a = 10;
	public void disp() {
		
	}
	public void aaa() {
		
	}
	public AAA() {
		
	}
	public String toString() {
		return "hello";
	}
}
abstract class C{
	C(){};
	C(int a){};
}
class A{
	int a = 10;
	String name = "홍길동";
	public A() {
		
	}
	public A(int a) {
		this.a = a;
	}
}
class B extends A{
	int b = 20;
	public B() {
		super(); // 상위 클래스의 생성자를 호출한다.
	}
	
}
// A a = new B() => A에 있는 데이터만 사용, 메소드는 변경된 것만 사용/
// 하위 클래스에서 추가된 메소드, 변수는 사용할 수 없다.
// B b = new B(); 
public class 정리_7장 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
//		String s1 = "hello";
//		String s2 = "hello";
//		String s3 = new String("hello");
//		if(s1 == s2) {
//			System.out.println("같다 (참조주소)");
//		}
		Object o = new AAA();
		o.toString();
		
//		AAA a = (AAA)o; // 형변환을 통해 AAA에 참조가 가능하다.
//		System.out.println(a.a);
		
	}

}
