package com.sist.lib;
/*
 *    컬렉션 프레임워크 
 *    ------------ 
 *    1. 다수의 데이터를 쉽고 효율적으로 처리할 수 있게 만들 표준화된 클래스의 집합
 *                   --------------- 자바에서 라이브러리로 지원
 *    2. 데이터 -> 수정, 삭제, 추가, 읽기 (자료구조)
 *    3. 배열 = 정적 메모리 할당 (추가가 어렵다.)
 *       => 동적 메모리 할당 (추가를 쉽게.)
 *          ------------ 추가시 자동으로 메모리를 추가
 *    4. 컬렉션의 종류 
 *       = 순서가 존재, 데이터의 중복허용
 *         List(인터페이스) 
 *           |
 *         ArrayList, Vector, LinkedList
 *         ---------
 *       = 순서가 없고, 데이터중복 불가
 *         Set(인터페이스)
 *          |
 *         HashSet, TreeSet(검색)
 *         ------- 웹 채팅(중복사용자 제거), List의 중복된 데이터 추출
 *       = 먼저 들어온 데이터를 먼저 출력
 *         Queue(FIFO) , Stack(LIFO) -> 코테 
 *         -----------   -----------
 *         순서적으로       뒤에서  ==>1차원배열
 *         Queue;
 *         for(int i =0 ; i< ar.length;i++){
 *             값 설정
 *         }
 *         for(int i =0 ; i< ar.length;i++){
 *             출력
 *         }
 *       =======================================
 *         Stack;
 *         for(int i =0 ; i< ar.length;i++){
 *             값 설정
 *         }
 *         for(int i =ar.length-1 ; i>=0;i--){
 *             출력
 *         }
 *       = Key-Value 동시에 저장              
 *         Map (인터페이스)
 *          |
 *         HashMap, Hashtable
 *         ------- Hashtable의 단점을 보완  
 *         
 *   --------------------------------------------------
			        전체 상속도
			        Collection
			            |
		-----------------------------------             
		|              |                   |
	  List            Set                Queue	     Map
	   |               |                   |          |
	 --- **ArrayList --- **HashSet                 --- **HashMap   
	 --- LinkedList  --- HashTree                  --- Hahstable
	 --- Vector 
	       | 
	     Stack  
	-----------------------------------------------------------------
	1. List
	   중복 데이터를 저장해야 할때, 저장순서는 인덱스(순차적으로 저장)
	   인덱스 번호가 항상 0 번 부터 순차적으로 유지
	   ----------------------------------
	   추가, 삭제, (배열에서의 단점 => 추가 , 삭제 => 새로운 배열) 정적이다
	   0
	   1
	   2
	   3
	   4
	   5...
	   --------------------------------------------------
	   0
	   1
	   2
	   3 => 삭제시 자동으로 index를 바꿔준다.
	   4 ->3
	   5 ->4
	   
	   => 구현 클래스
	   ArrayList
	   ---------
	   1. 단방향 포인터(인덱스)를 가지고 있다-> 조회하기 쉽다.
	   2. 검색이 빠르다. 데이터 추가시 속도가 빠르다
	   3. 단점) 수정, 중간에 추가, 삭제에 속도가 느려진다.
	   4. ----------------------- LinkedList가 더 빠르다
	   5. 변경, 삭제가 없는 상태에서 주로 사용
	      ---------------------------- 데이터베이스(오라클)
	      데이터베이스가 핵심인 프로그램 => 웹
	   
	   LinkedList
	   ----------
	   1. 양뱡향 포인터 가지고 있다
	   2. 수정, 삭제, 추가가 많은 경우에 주로 사용
	   3. 단점 : 검색속도가 느리다.
	   
	   Vector : 유지보수
	   ------
	   1. 대용량 데이터 처리 -> 채팅프로그램, 서버연결
	   2.                   --         ----  (동기화) -> 속도가 조금 느리다.
	   3. 비동기 보완된 프로그램 => ArrayList
	   
	   *** 데이터는 반드시 구분이 되게 만든다.
	   hong1 홍길동 남자 
	   hong1 홍길동 남자
	   hong1 홍길동 남자  동명이인 3명 -> 본인이 아닐 수도 있음 
	2. Set
	   순서가 없다.(인덱스 번호가 없다.) , 데이터 중복을 허용하지 않는다.
	   => 장르별 / 부서별 ...
	   => 데이터베이스 이용
	   => 중복없는 데이터 -> DISTINCT
	   => HashSet => 속도가 빠르다.
	   => TresSet => 정렬, 검색에 용이하다
	
	3. Map
	   Key - Value 를 같이 저장
	   구분자 => 찾기
	   웹에서 주로 사용, 클래스를 관리, 도서목록, 우편번호   
	   => *HashMap
 *        Hashtable --> 속도가 느리다     속도가 빠른 HashMap을 사용
 *  
 *  
 *  Set 클래스 (인터페이스)
 *  ------------------------
 *        Collection
 *            |
 *           Set -------- 인터페이스
 *            |
 *      ----------------
 *      |              |
 *    HashSet         TreeSet
 *    -------
 *     1) 순서가 없다(인덱스가 존재하지 않는다)
 *     2) 데이터중복을 허용하지 않는다.
 *     3) 주요 메소드
 *        => 데이터 저장 : add() => Object
 *        => 삭제 : remove(Object);
 *        => 전체 삭제 : clear() 
 *        => isEmpty() : 빈공간 (데이터 존재여부 확인)
 *        => 저장갯수 : size()
 *        => 데이터를 한번에 모아서 관리 : iterator();
 *      => TreeSet : 검색용으로 주로 사용
 *       			 LIKE , REGEXP_LIKE(오라클)
 *         = headSet
 *         = tailSet
 *         
 *               
 *             
 *    
 */
import java.util.*;

public class 라이브러리_Collection {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Set set = new HashSet();
		set.add("A");
		set.add("B");
		set.add("C");
		set.add("D");
		// 중복된 데이터는 허용하지 않는다.
		set.add("B");
		set.add("A");
		set.add("C");
		set.add("B");
		set.add("A");
		
		// 출력
		for(Object obj : set) {
			// for - each 구문은 형변환이 안된다.
//			System.out.println(obj);
			 String s = (String)obj;// 가능
			 System.out.println(s+" ");
			 // 중복으로 데이터를 삽입하지 않는다.
			 
		}
	}

}
